// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium -Af resources/istio/v1_11_0/networking/v1beta1/DestinationRule.yaml --api-version v1beta1
// kopium version: 0.20.0

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "networking.istio.io", version = "v1beta1", kind = "DestinationRule", plural = "destinationrules")]
#[kube(namespaced)]
pub struct DestinationRuleSpec {
    /// A list of namespaces to which this destination rule is exported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exportTo")]
    pub export_to: Option<Vec<String>>,
    /// The name of a service from the service registry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subsets: Option<Vec<DestinationRuleSubsets>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trafficPolicy")]
    pub traffic_policy: Option<DestinationRuleTrafficPolicy>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsets {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Name of the subset.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Traffic policies that apply to this subset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trafficPolicy")]
    pub traffic_policy: Option<DestinationRuleSubsetsTrafficPolicy>,
}

/// Traffic policies that apply to this subset.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicy {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionPool")]
    pub connection_pool: Option<DestinationRuleSubsetsTrafficPolicyConnectionPool>,
    /// Settings controlling the load balancer algorithms.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancer")]
    pub load_balancer: Option<DestinationRuleSubsetsTrafficPolicyLoadBalancer>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outlierDetection")]
    pub outlier_detection: Option<DestinationRuleSubsetsTrafficPolicyOutlierDetection>,
    /// Traffic policies specific to individual ports.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portLevelSettings")]
    pub port_level_settings: Option<Vec<DestinationRuleSubsetsTrafficPolicyPortLevelSettings>>,
    /// TLS related settings for connections to the upstream service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<DestinationRuleSubsetsTrafficPolicyTls>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyConnectionPool {
    /// HTTP connection pool settings.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<DestinationRuleSubsetsTrafficPolicyConnectionPoolHttp>,
    /// Settings common to both HTTP and TCP upstream connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tcp: Option<DestinationRuleSubsetsTrafficPolicyConnectionPoolTcp>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyConnectionPoolHttp {
    /// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "h2UpgradePolicy")]
    pub h2_upgrade_policy: Option<DestinationRuleSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy>,
    /// Maximum number of pending HTTP requests to a destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http1MaxPendingRequests")]
    pub http1_max_pending_requests: Option<i32>,
    /// Maximum number of requests to a backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http2MaxRequests")]
    pub http2_max_requests: Option<i32>,
    /// The idle timeout for upstream connection pool connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleTimeout")]
    pub idle_timeout: Option<String>,
    /// Maximum number of requests per connection to a backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequestsPerConnection")]
    pub max_requests_per_connection: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i32>,
    /// If set to true, client protocol will be preserved while initiating connection to backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useClientProtocol")]
    pub use_client_protocol: Option<bool>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DestinationRuleSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "DO_NOT_UPGRADE")]
    DoNotUpgrade,
    #[serde(rename = "UPGRADE")]
    Upgrade,
}

/// Settings common to both HTTP and TCP upstream connections.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyConnectionPoolTcp {
    /// TCP connection timeout.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<String>,
    /// Maximum number of HTTP1 /TCP connections to a destination host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnections")]
    pub max_connections: Option<i32>,
    /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpKeepalive")]
    pub tcp_keepalive: Option<DestinationRuleSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive>,
}

/// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive {
    /// The time duration between keep-alive probes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probes: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyLoadBalancer {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consistentHash")]
    pub consistent_hash: Option<DestinationRuleSubsetsTrafficPolicyLoadBalancerConsistentHash>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localityLbSetting")]
    pub locality_lb_setting: Option<DestinationRuleSubsetsTrafficPolicyLoadBalancerLocalityLbSetting>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub simple: Option<DestinationRuleSubsetsTrafficPolicyLoadBalancerSimple>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyLoadBalancerConsistentHash {
    /// Hash based on HTTP cookie.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpCookie")]
    pub http_cookie: Option<DestinationRuleSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie>,
    /// Hash based on a specific HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaderName")]
    pub http_header_name: Option<String>,
    /// Hash based on a specific HTTP query parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpQueryParameterName")]
    pub http_query_parameter_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumRingSize")]
    pub minimum_ring_size: Option<i64>,
    /// Hash based on the source IP address.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useSourceIp")]
    pub use_source_ip: Option<bool>,
}

/// Hash based on HTTP cookie.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie {
    /// Name of the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Path to set for the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Lifetime of the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyLoadBalancerLocalityLbSetting {
    /// Optional: only one of distribute or failover can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distribute: Option<Vec<DestinationRuleSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute>>,
    /// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Optional: only failover or distribute can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failover: Option<Vec<DestinationRuleSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
    /// Originating locality, '/' separated, e.g.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    /// Map of upstream localities to traffic distribution weights.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<BTreeMap<String, i64>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover {
    /// Originating region.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DestinationRuleSubsetsTrafficPolicyLoadBalancerSimple {
    #[serde(rename = "ROUND_ROBIN")]
    RoundRobin,
    #[serde(rename = "LEAST_CONN")]
    LeastConn,
    #[serde(rename = "RANDOM")]
    Random,
    #[serde(rename = "PASSTHROUGH")]
    Passthrough,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyOutlierDetection {
    /// Minimum ejection duration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseEjectionTime")]
    pub base_ejection_time: Option<String>,
    /// Number of 5xx errors before a host is ejected from the connection pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutive5xxErrors")]
    pub consecutive5xx_errors: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveErrors")]
    pub consecutive_errors: Option<i32>,
    /// Number of gateway errors before a host is ejected from the connection pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveGatewayErrors")]
    pub consecutive_gateway_errors: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveLocalOriginFailures")]
    pub consecutive_local_origin_failures: Option<i64>,
    /// Time interval between ejection sweep analysis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxEjectionPercent")]
    pub max_ejection_percent: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minHealthPercent")]
    pub min_health_percent: Option<i32>,
    /// Determines whether to distinguish local origin failures from external errors.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "splitExternalLocalOriginErrors")]
    pub split_external_local_origin_errors: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettings {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionPool")]
    pub connection_pool: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPool>,
    /// Settings controlling the load balancer algorithms.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancer")]
    pub load_balancer: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancer>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outlierDetection")]
    pub outlier_detection: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsOutlierDetection>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsPort>,
    /// TLS related settings for connections to the upstream service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsTls>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPool {
    /// HTTP connection pool settings.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp>,
    /// Settings common to both HTTP and TCP upstream connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tcp: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp {
    /// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "h2UpgradePolicy")]
    pub h2_upgrade_policy: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy>,
    /// Maximum number of pending HTTP requests to a destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http1MaxPendingRequests")]
    pub http1_max_pending_requests: Option<i32>,
    /// Maximum number of requests to a backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http2MaxRequests")]
    pub http2_max_requests: Option<i32>,
    /// The idle timeout for upstream connection pool connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleTimeout")]
    pub idle_timeout: Option<String>,
    /// Maximum number of requests per connection to a backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequestsPerConnection")]
    pub max_requests_per_connection: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i32>,
    /// If set to true, client protocol will be preserved while initiating connection to backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useClientProtocol")]
    pub use_client_protocol: Option<bool>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "DO_NOT_UPGRADE")]
    DoNotUpgrade,
    #[serde(rename = "UPGRADE")]
    Upgrade,
}

/// Settings common to both HTTP and TCP upstream connections.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp {
    /// TCP connection timeout.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<String>,
    /// Maximum number of HTTP1 /TCP connections to a destination host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnections")]
    pub max_connections: Option<i32>,
    /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpKeepalive")]
    pub tcp_keepalive: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive>,
}

/// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
    /// The time duration between keep-alive probes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probes: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancer {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consistentHash")]
    pub consistent_hash: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localityLbSetting")]
    pub locality_lb_setting: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub simple: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash {
    /// Hash based on HTTP cookie.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpCookie")]
    pub http_cookie: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie>,
    /// Hash based on a specific HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaderName")]
    pub http_header_name: Option<String>,
    /// Hash based on a specific HTTP query parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpQueryParameterName")]
    pub http_query_parameter_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumRingSize")]
    pub minimum_ring_size: Option<i64>,
    /// Hash based on the source IP address.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useSourceIp")]
    pub use_source_ip: Option<bool>,
}

/// Hash based on HTTP cookie.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie {
    /// Name of the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Path to set for the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Lifetime of the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting {
    /// Optional: only one of distribute or failover can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distribute: Option<Vec<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute>>,
    /// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Optional: only failover or distribute can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failover: Option<Vec<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute {
    /// Originating locality, '/' separated, e.g.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    /// Map of upstream localities to traffic distribution weights.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<BTreeMap<String, i64>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover {
    /// Originating region.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple {
    #[serde(rename = "ROUND_ROBIN")]
    RoundRobin,
    #[serde(rename = "LEAST_CONN")]
    LeastConn,
    #[serde(rename = "RANDOM")]
    Random,
    #[serde(rename = "PASSTHROUGH")]
    Passthrough,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsOutlierDetection {
    /// Minimum ejection duration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseEjectionTime")]
    pub base_ejection_time: Option<String>,
    /// Number of 5xx errors before a host is ejected from the connection pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutive5xxErrors")]
    pub consecutive5xx_errors: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveErrors")]
    pub consecutive_errors: Option<i32>,
    /// Number of gateway errors before a host is ejected from the connection pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveGatewayErrors")]
    pub consecutive_gateway_errors: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveLocalOriginFailures")]
    pub consecutive_local_origin_failures: Option<i64>,
    /// Time interval between ejection sweep analysis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxEjectionPercent")]
    pub max_ejection_percent: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minHealthPercent")]
    pub min_health_percent: Option<i32>,
    /// Determines whether to distinguish local origin failures from external errors.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "splitExternalLocalOriginErrors")]
    pub split_external_local_origin_errors: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsPort {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub number: Option<i64>,
}

/// TLS related settings for connections to the upstream service.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsTls {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCertificates")]
    pub ca_certificates: Option<String>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCertificate")]
    pub client_certificate: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialName")]
    pub credential_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsTlsMode>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    /// SNI string to present to the server during TLS handshake.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sni: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectAltNames")]
    pub subject_alt_names: Option<Vec<String>>,
}

/// TLS related settings for connections to the upstream service.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DestinationRuleSubsetsTrafficPolicyPortLevelSettingsTlsMode {
    #[serde(rename = "DISABLE")]
    Disable,
    #[serde(rename = "SIMPLE")]
    Simple,
    #[serde(rename = "MUTUAL")]
    Mutual,
    #[serde(rename = "ISTIO_MUTUAL")]
    IstioMutual,
}

/// TLS related settings for connections to the upstream service.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleSubsetsTrafficPolicyTls {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCertificates")]
    pub ca_certificates: Option<String>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCertificate")]
    pub client_certificate: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialName")]
    pub credential_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<DestinationRuleSubsetsTrafficPolicyTlsMode>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    /// SNI string to present to the server during TLS handshake.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sni: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectAltNames")]
    pub subject_alt_names: Option<Vec<String>>,
}

/// TLS related settings for connections to the upstream service.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DestinationRuleSubsetsTrafficPolicyTlsMode {
    #[serde(rename = "DISABLE")]
    Disable,
    #[serde(rename = "SIMPLE")]
    Simple,
    #[serde(rename = "MUTUAL")]
    Mutual,
    #[serde(rename = "ISTIO_MUTUAL")]
    IstioMutual,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicy {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionPool")]
    pub connection_pool: Option<DestinationRuleTrafficPolicyConnectionPool>,
    /// Settings controlling the load balancer algorithms.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancer")]
    pub load_balancer: Option<DestinationRuleTrafficPolicyLoadBalancer>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outlierDetection")]
    pub outlier_detection: Option<DestinationRuleTrafficPolicyOutlierDetection>,
    /// Traffic policies specific to individual ports.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portLevelSettings")]
    pub port_level_settings: Option<Vec<DestinationRuleTrafficPolicyPortLevelSettings>>,
    /// TLS related settings for connections to the upstream service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<DestinationRuleTrafficPolicyTls>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyConnectionPool {
    /// HTTP connection pool settings.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<DestinationRuleTrafficPolicyConnectionPoolHttp>,
    /// Settings common to both HTTP and TCP upstream connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tcp: Option<DestinationRuleTrafficPolicyConnectionPoolTcp>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyConnectionPoolHttp {
    /// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "h2UpgradePolicy")]
    pub h2_upgrade_policy: Option<DestinationRuleTrafficPolicyConnectionPoolHttpH2UpgradePolicy>,
    /// Maximum number of pending HTTP requests to a destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http1MaxPendingRequests")]
    pub http1_max_pending_requests: Option<i32>,
    /// Maximum number of requests to a backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http2MaxRequests")]
    pub http2_max_requests: Option<i32>,
    /// The idle timeout for upstream connection pool connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleTimeout")]
    pub idle_timeout: Option<String>,
    /// Maximum number of requests per connection to a backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequestsPerConnection")]
    pub max_requests_per_connection: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i32>,
    /// If set to true, client protocol will be preserved while initiating connection to backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useClientProtocol")]
    pub use_client_protocol: Option<bool>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DestinationRuleTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "DO_NOT_UPGRADE")]
    DoNotUpgrade,
    #[serde(rename = "UPGRADE")]
    Upgrade,
}

/// Settings common to both HTTP and TCP upstream connections.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyConnectionPoolTcp {
    /// TCP connection timeout.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<String>,
    /// Maximum number of HTTP1 /TCP connections to a destination host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnections")]
    pub max_connections: Option<i32>,
    /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpKeepalive")]
    pub tcp_keepalive: Option<DestinationRuleTrafficPolicyConnectionPoolTcpTcpKeepalive>,
}

/// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyConnectionPoolTcpTcpKeepalive {
    /// The time duration between keep-alive probes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probes: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyLoadBalancer {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consistentHash")]
    pub consistent_hash: Option<DestinationRuleTrafficPolicyLoadBalancerConsistentHash>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localityLbSetting")]
    pub locality_lb_setting: Option<DestinationRuleTrafficPolicyLoadBalancerLocalityLbSetting>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub simple: Option<DestinationRuleTrafficPolicyLoadBalancerSimple>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyLoadBalancerConsistentHash {
    /// Hash based on HTTP cookie.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpCookie")]
    pub http_cookie: Option<DestinationRuleTrafficPolicyLoadBalancerConsistentHashHttpCookie>,
    /// Hash based on a specific HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaderName")]
    pub http_header_name: Option<String>,
    /// Hash based on a specific HTTP query parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpQueryParameterName")]
    pub http_query_parameter_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumRingSize")]
    pub minimum_ring_size: Option<i64>,
    /// Hash based on the source IP address.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useSourceIp")]
    pub use_source_ip: Option<bool>,
}

/// Hash based on HTTP cookie.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyLoadBalancerConsistentHashHttpCookie {
    /// Name of the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Path to set for the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Lifetime of the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyLoadBalancerLocalityLbSetting {
    /// Optional: only one of distribute or failover can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distribute: Option<Vec<DestinationRuleTrafficPolicyLoadBalancerLocalityLbSettingDistribute>>,
    /// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Optional: only failover or distribute can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failover: Option<Vec<DestinationRuleTrafficPolicyLoadBalancerLocalityLbSettingFailover>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
    /// Originating locality, '/' separated, e.g.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    /// Map of upstream localities to traffic distribution weights.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<BTreeMap<String, i64>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyLoadBalancerLocalityLbSettingFailover {
    /// Originating region.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DestinationRuleTrafficPolicyLoadBalancerSimple {
    #[serde(rename = "ROUND_ROBIN")]
    RoundRobin,
    #[serde(rename = "LEAST_CONN")]
    LeastConn,
    #[serde(rename = "RANDOM")]
    Random,
    #[serde(rename = "PASSTHROUGH")]
    Passthrough,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyOutlierDetection {
    /// Minimum ejection duration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseEjectionTime")]
    pub base_ejection_time: Option<String>,
    /// Number of 5xx errors before a host is ejected from the connection pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutive5xxErrors")]
    pub consecutive5xx_errors: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveErrors")]
    pub consecutive_errors: Option<i32>,
    /// Number of gateway errors before a host is ejected from the connection pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveGatewayErrors")]
    pub consecutive_gateway_errors: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveLocalOriginFailures")]
    pub consecutive_local_origin_failures: Option<i64>,
    /// Time interval between ejection sweep analysis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxEjectionPercent")]
    pub max_ejection_percent: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minHealthPercent")]
    pub min_health_percent: Option<i32>,
    /// Determines whether to distinguish local origin failures from external errors.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "splitExternalLocalOriginErrors")]
    pub split_external_local_origin_errors: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyPortLevelSettings {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionPool")]
    pub connection_pool: Option<DestinationRuleTrafficPolicyPortLevelSettingsConnectionPool>,
    /// Settings controlling the load balancer algorithms.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancer")]
    pub load_balancer: Option<DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancer>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outlierDetection")]
    pub outlier_detection: Option<DestinationRuleTrafficPolicyPortLevelSettingsOutlierDetection>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<DestinationRuleTrafficPolicyPortLevelSettingsPort>,
    /// TLS related settings for connections to the upstream service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<DestinationRuleTrafficPolicyPortLevelSettingsTls>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsConnectionPool {
    /// HTTP connection pool settings.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<DestinationRuleTrafficPolicyPortLevelSettingsConnectionPoolHttp>,
    /// Settings common to both HTTP and TCP upstream connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tcp: Option<DestinationRuleTrafficPolicyPortLevelSettingsConnectionPoolTcp>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsConnectionPoolHttp {
    /// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "h2UpgradePolicy")]
    pub h2_upgrade_policy: Option<DestinationRuleTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy>,
    /// Maximum number of pending HTTP requests to a destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http1MaxPendingRequests")]
    pub http1_max_pending_requests: Option<i32>,
    /// Maximum number of requests to a backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http2MaxRequests")]
    pub http2_max_requests: Option<i32>,
    /// The idle timeout for upstream connection pool connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleTimeout")]
    pub idle_timeout: Option<String>,
    /// Maximum number of requests per connection to a backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequestsPerConnection")]
    pub max_requests_per_connection: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i32>,
    /// If set to true, client protocol will be preserved while initiating connection to backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useClientProtocol")]
    pub use_client_protocol: Option<bool>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DestinationRuleTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "DO_NOT_UPGRADE")]
    DoNotUpgrade,
    #[serde(rename = "UPGRADE")]
    Upgrade,
}

/// Settings common to both HTTP and TCP upstream connections.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsConnectionPoolTcp {
    /// TCP connection timeout.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<String>,
    /// Maximum number of HTTP1 /TCP connections to a destination host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnections")]
    pub max_connections: Option<i32>,
    /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpKeepalive")]
    pub tcp_keepalive: Option<DestinationRuleTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive>,
}

/// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
    /// The time duration between keep-alive probes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probes: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancer {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consistentHash")]
    pub consistent_hash: Option<DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localityLbSetting")]
    pub locality_lb_setting: Option<DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub simple: Option<DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerSimple>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash {
    /// Hash based on HTTP cookie.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpCookie")]
    pub http_cookie: Option<DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie>,
    /// Hash based on a specific HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaderName")]
    pub http_header_name: Option<String>,
    /// Hash based on a specific HTTP query parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpQueryParameterName")]
    pub http_query_parameter_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumRingSize")]
    pub minimum_ring_size: Option<i64>,
    /// Hash based on the source IP address.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useSourceIp")]
    pub use_source_ip: Option<bool>,
}

/// Hash based on HTTP cookie.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie {
    /// Name of the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Path to set for the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Lifetime of the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting {
    /// Optional: only one of distribute or failover can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distribute: Option<Vec<DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute>>,
    /// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Optional: only failover or distribute can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failover: Option<Vec<DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute {
    /// Originating locality, '/' separated, e.g.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    /// Map of upstream localities to traffic distribution weights.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<BTreeMap<String, i64>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover {
    /// Originating region.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerSimple {
    #[serde(rename = "ROUND_ROBIN")]
    RoundRobin,
    #[serde(rename = "LEAST_CONN")]
    LeastConn,
    #[serde(rename = "RANDOM")]
    Random,
    #[serde(rename = "PASSTHROUGH")]
    Passthrough,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsOutlierDetection {
    /// Minimum ejection duration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseEjectionTime")]
    pub base_ejection_time: Option<String>,
    /// Number of 5xx errors before a host is ejected from the connection pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutive5xxErrors")]
    pub consecutive5xx_errors: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveErrors")]
    pub consecutive_errors: Option<i32>,
    /// Number of gateway errors before a host is ejected from the connection pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveGatewayErrors")]
    pub consecutive_gateway_errors: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveLocalOriginFailures")]
    pub consecutive_local_origin_failures: Option<i64>,
    /// Time interval between ejection sweep analysis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxEjectionPercent")]
    pub max_ejection_percent: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minHealthPercent")]
    pub min_health_percent: Option<i32>,
    /// Determines whether to distinguish local origin failures from external errors.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "splitExternalLocalOriginErrors")]
    pub split_external_local_origin_errors: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsPort {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub number: Option<i64>,
}

/// TLS related settings for connections to the upstream service.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsTls {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCertificates")]
    pub ca_certificates: Option<String>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCertificate")]
    pub client_certificate: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialName")]
    pub credential_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<DestinationRuleTrafficPolicyPortLevelSettingsTlsMode>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    /// SNI string to present to the server during TLS handshake.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sni: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectAltNames")]
    pub subject_alt_names: Option<Vec<String>>,
}

/// TLS related settings for connections to the upstream service.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DestinationRuleTrafficPolicyPortLevelSettingsTlsMode {
    #[serde(rename = "DISABLE")]
    Disable,
    #[serde(rename = "SIMPLE")]
    Simple,
    #[serde(rename = "MUTUAL")]
    Mutual,
    #[serde(rename = "ISTIO_MUTUAL")]
    IstioMutual,
}

/// TLS related settings for connections to the upstream service.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DestinationRuleTrafficPolicyTls {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCertificates")]
    pub ca_certificates: Option<String>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCertificate")]
    pub client_certificate: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialName")]
    pub credential_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<DestinationRuleTrafficPolicyTlsMode>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    /// SNI string to present to the server during TLS handshake.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sni: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectAltNames")]
    pub subject_alt_names: Option<Vec<String>>,
}

/// TLS related settings for connections to the upstream service.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum DestinationRuleTrafficPolicyTlsMode {
    #[serde(rename = "DISABLE")]
    Disable,
    #[serde(rename = "SIMPLE")]
    Simple,
    #[serde(rename = "MUTUAL")]
    Mutual,
    #[serde(rename = "ISTIO_MUTUAL")]
    IstioMutual,
}

