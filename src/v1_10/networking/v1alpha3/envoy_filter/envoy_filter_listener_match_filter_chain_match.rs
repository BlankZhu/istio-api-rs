use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
/*
 * Customizing Envoy configuration generated by Istio.
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1alpha3
 * 
 * Generated by: https://openapi-generator.tech
 */

/// EnvoyFilterListenerMatchFilterChainMatch : For listeners with multiple filter chains (e.g., inbound listeners on sidecars with permissive mTLS, gateway listeners with multiple SNI matches), the filter chain match can be used to select a specific filter chain to patch.



#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize, JsonSchema)]
pub struct EnvoyFilterListenerMatchFilterChainMatch {
    /// Applies only to sidecars. If non-empty, a comma separated set of application protocols to consider when determining a filter chain match. This value will be compared against the application protocols of a new connection, when it's detected by one of the listener filters such as the `http_inspector`.
    #[serde(rename = "applicationProtocols", skip_serializing_if = "Option::is_none")]
    pub application_protocols: Option<String>,
    /// The destination_port value used by a filter chain's match condition. This condition will evaluate to false if the filter chain has no destination_port match.
    #[serde(rename = "destinationPort", skip_serializing_if = "Option::is_none")]
    pub destination_port: Option<i32>,
    #[serde(rename = "filter", skip_serializing_if = "Option::is_none")]
    pub filter: Option<Box<super::EnvoyFilterListenerMatchFilterMatch>>,
    /// The name assigned to the filter chain.
    #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The SNI value used by a filter chain's match condition. This condition will evaluate to false if the filter chain has no sni match.
    #[serde(rename = "sni", skip_serializing_if = "Option::is_none")]
    pub sni: Option<String>,
    /// Applies only to `SIDECAR_INBOUND` context. If non-empty, a transport protocol to consider when determining a filter chain match. This value will be compared against the transport protocol of a new connection, when it's detected by the `tls_inspector` listener filter.
    #[serde(rename = "transportProtocol", skip_serializing_if = "Option::is_none")]
    pub transport_protocol: Option<String>,
}

impl EnvoyFilterListenerMatchFilterChainMatch {
    /// For listeners with multiple filter chains (e.g., inbound listeners on sidecars with permissive mTLS, gateway listeners with multiple SNI matches), the filter chain match can be used to select a specific filter chain to patch.
    pub fn new() -> EnvoyFilterListenerMatchFilterChainMatch {
        EnvoyFilterListenerMatchFilterChainMatch {
            application_protocols: None,
            destination_port: None,
            filter: None,
            name: None,
            sni: None,
            transport_protocol: None,
        }
    }
}